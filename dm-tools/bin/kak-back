#!/usr/bin/env python3

""" Creates a copy of every written kak file in
./local/share/kak/backups/%path%to%file
so that it can be restored later on
"""

import argparse
import datetime
import os
import shutil
import sys


BACKUPS_PATH = os.path.expanduser("~/.local/share/kak/backups")
ONE_MONTH = 60 * 60 * 24 * 30  # à une vache près


def canonalize_path(path):
    abspath = os.path.abspath(path)
    return os.path.realpath(abspath)


class BackupStore:
    def __init__(self, path):
        self.path = path
        os.makedirs(self.path, exist_ok=True)

    def backup(self, src_path):
        src_path = canonalize_path(src_path)
        backup_path = self.to_backup_path(src_path)
        shutil.copy(src_path, backup_path)

    def restore(self, dest):
        dest = canonalize_path(dest)
        backup_path = self.to_backup_path(dest)
        if os.path.exists(backup_path):
            shutil.copy(backup_path, dest)
            return True
        else:
            sys.exit(f"Expected backup in {backup_path}, but no such file exists")

    def list_entries(self):
        entries = list(self.get_entries())
        entries.sort(key=self.get_mtime)
        for name in entries:
            print(name.replace("%", "/"))

    def clean(self, *, dry_run):
        total = 0
        cleaned = 0
        now = datetime.datetime.now().timestamp()
        for entry_name in self.get_entries():
            total += 1
            mtime = self.get_mtime(entry_name)
            if now - mtime > ONE_MONTH:
                cleaned += 1
                if not dry_run:
                    full_path = os.path.join(self.path, entry_name)
                    os.remove(full_path)
        if dry_run:
            print(f"Would remove {cleaned}/{total} entries")
        else:
            print(f"Removed {cleaned}/{total} entries")

    def get_entries(self):
        for entry_name in os.listdir(self.path):
            full_path = os.path.join(self.path, entry_name)
            if not os.path.isfile(full_path):
                continue
            yield entry_name

    def to_backup_path(self, full_path):
        entry_name = full_path.replace("/", "%")
        return os.path.join(self.path, entry_name)

    def get_mtime(self, entry_name):
        full_path = os.path.join(self.path, entry_name)
        return os.stat(full_path).st_mtime


def main():
    parser = argparse.ArgumentParser()

    subparsers = parser.add_subparsers(title="commands", dest="command")

    backup_parser = subparsers.add_parser("backup")
    backup_parser.add_argument("path")

    restore_parser = subparsers.add_parser("restore")
    restore_parser.add_argument("path")

    clean_parser = subparsers.add_parser("clean")
    clean_parser.add_argument("--dry-run", action="store_true")

    subparsers.add_parser("list", aliases=["ls"])

    args = parser.parse_args()
    command = args.command

    store = BackupStore(BACKUPS_PATH)
    if command == "backup":
        store.backup(args.path)
    elif command == "restore":
        store.restore(args.path)
    elif command == "clean":
        store.clean(dry_run=args.dry_run)
    elif command in ("ls", "list"):
        store.list_entries()
    else:
        parser.print_help()
        sys.exit(1)


if __name__ == "__main__":
    main()
